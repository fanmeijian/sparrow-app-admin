import { FlatTreeControl } from '@angular/cdk/tree';
import { Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { TREE_SERVICE, TreeDataSource } from '../sortable-tree/dynamic-data-source';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/router";
import * as i3 from "@angular/material/tree";
import * as i4 from "@angular/material/icon";
import * as i5 from "@angular/material/progress-spinner";
import * as i6 from "@angular/material/button";
export class MenuComponent {
    constructor(treeService) {
        this.treeService = treeService;
        this.multiple = true;
        this.onTreeSelect = new EventEmitter();
        this.hasChild = (_, node) => node.expandable;
        this.treeControl = new FlatTreeControl((node) => node.level, (node) => node.expandable);
    }
    ngOnInit() {
        this.dataSource = new TreeDataSource(this.treeControl, this.treeService);
        this.treeService.initialData().subscribe(res => {
            this.dataSource.data = res;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MenuComponent, deps: [{ token: TREE_SERVICE }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: MenuComponent, selector: "spr-menu", inputs: { multiple: "multiple" }, outputs: { onTreeSelect: "onTreeSelect" }, ngImport: i0, template: "<mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\">\n    <mat-tree-node *matTreeNodeDef=\"let node\" matTreeNodePadding>\n      <button mat-icon-button disabled></button>\n      <span [class]=\"\n          selectedNode === node.url\n            ? 'norml-tree-node selected-norml-tree-node'\n            : 'norml-tree-node'\n        \" [routerLink]=\"node.url\" (click)=\"selectedNode = node.url\">{{ node.name }}</span>\n    </mat-tree-node>\n\n    <mat-tree-node *matTreeNodeDef=\"let node; when: hasChild\" matTreeNodePadding>\n      <button type=\"button\" mat-icon-button matTreeNodeToggle [disabled]=\"node.isLoading\">\n        <mat-icon>\n          {{ treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right' }}\n        </mat-icon>\n      </button>\n      <span class=\"s-link\">{{ node.name }}</span>\n\n      <mat-spinner *ngIf=\"node.isLoading\" [diameter]=\"18\"></mat-spinner>\n            <div [class.example-tree-invisible]=\"!treeControl.isExpanded(node)\" role=\"group\">\n        <ng-container matTreeNodeOutlet></ng-container>\n      </div>\n    </mat-tree-node>\n  </mat-tree>\n", styles: [""], dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: i3.MatTreeNodeDef, selector: "[matTreeNodeDef]", inputs: ["matTreeNodeDefWhen", "matTreeNode"] }, { kind: "directive", type: i3.MatTreeNodePadding, selector: "[matTreeNodePadding]", inputs: ["matTreeNodePadding", "matTreeNodePaddingIndent"] }, { kind: "directive", type: i3.MatTreeNodeToggle, selector: "[matTreeNodeToggle]", inputs: ["matTreeNodeToggleRecursive"] }, { kind: "component", type: i3.MatTree, selector: "mat-tree", exportAs: ["matTree"] }, { kind: "directive", type: i3.MatTreeNode, selector: "mat-tree-node", inputs: ["role", "disabled", "tabIndex"], exportAs: ["matTreeNode"] }, { kind: "directive", type: i3.MatTreeNodeOutlet, selector: "[matTreeNodeOutlet]" }, { kind: "component", type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i5.MatProgressSpinner, selector: "mat-progress-spinner, mat-spinner", inputs: ["color", "mode", "value", "diameter", "strokeWidth"], exportAs: ["matProgressSpinner"] }, { kind: "component", type: i6.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MenuComponent, decorators: [{
            type: Component,
            args: [{ selector: 'spr-menu', template: "<mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\">\n    <mat-tree-node *matTreeNodeDef=\"let node\" matTreeNodePadding>\n      <button mat-icon-button disabled></button>\n      <span [class]=\"\n          selectedNode === node.url\n            ? 'norml-tree-node selected-norml-tree-node'\n            : 'norml-tree-node'\n        \" [routerLink]=\"node.url\" (click)=\"selectedNode = node.url\">{{ node.name }}</span>\n    </mat-tree-node>\n\n    <mat-tree-node *matTreeNodeDef=\"let node; when: hasChild\" matTreeNodePadding>\n      <button type=\"button\" mat-icon-button matTreeNodeToggle [disabled]=\"node.isLoading\">\n        <mat-icon>\n          {{ treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right' }}\n        </mat-icon>\n      </button>\n      <span class=\"s-link\">{{ node.name }}</span>\n\n      <mat-spinner *ngIf=\"node.isLoading\" [diameter]=\"18\"></mat-spinner>\n            <div [class.example-tree-invisible]=\"!treeControl.isExpanded(node)\" role=\"group\">\n        <ng-container matTreeNodeOutlet></ng-container>\n      </div>\n    </mat-tree-node>\n  </mat-tree>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [TREE_SERVICE]
                }] }]; }, propDecorators: { multiple: [{
                type: Input
            }], onTreeSelect: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVudS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb21tb24tdWktbm0vc3JjL2xpYi90cmVlL21lbnUvbWVudS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb21tb24tdWktbm0vc3JjL2xpYi90cmVlL21lbnUvbWVudS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFcEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBVSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHdkYsT0FBTyxFQUFtQixZQUFZLEVBQUUsY0FBYyxFQUFlLE1BQU0sc0NBQXNDLENBQUM7Ozs7Ozs7O0FBUWxILE1BQU0sT0FBTyxhQUFhO0lBUXhCLFlBQytCLFdBQXdCO1FBQXhCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBUDlDLGFBQVEsR0FBWSxJQUFJLENBQUE7UUFDdkIsaUJBQVksR0FBb0MsSUFBSSxZQUFZLEVBQXFCLENBQUE7UUFlL0YsYUFBUSxHQUFHLENBQUMsQ0FBUyxFQUFFLElBQXFCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7UUFHakUsZ0JBQVcsR0FBRyxJQUFJLGVBQWUsQ0FDL0IsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQ3BCLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUMxQixDQUFDO0lBZEUsQ0FBQztJQUNMLFFBQVE7UUFDTixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3pFLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzdDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQTtRQUM1QixDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUM7K0dBaEJVLGFBQWEsa0JBU2QsWUFBWTttR0FUWCxhQUFhLDZIQ2IxQixtbUNBd0JBOzs0RkRYYSxhQUFhO2tCQUx6QixTQUFTOytCQUNFLFVBQVU7OzBCQWFqQixNQUFNOzJCQUFDLFlBQVk7NENBUGIsUUFBUTtzQkFBaEIsS0FBSztnQkFDSSxZQUFZO3NCQUFyQixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRmxhdFRyZWVDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3RyZWUnO1xuaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbmplY3QsIElucHV0LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0RGlhbG9nIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZGlhbG9nJztcbmltcG9ydCB7IE1hdFRyZWVGbGF0dGVuZXIgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC90cmVlJztcbmltcG9ydCB7IER5bmFtaWNGbGF0Tm9kZSwgVFJFRV9TRVJWSUNFLCBUcmVlRGF0YVNvdXJjZSwgVHJlZVNlcnZpY2UgfSBmcm9tICcuLi9zb3J0YWJsZS10cmVlL2R5bmFtaWMtZGF0YS1zb3VyY2UnO1xuXG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3Nwci1tZW51JyxcbiAgdGVtcGxhdGVVcmw6ICcuL21lbnUuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9tZW51LmNvbXBvbmVudC5jc3MnXSxcbn0pXG5leHBvcnQgY2xhc3MgTWVudUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgQElucHV0KCkgbXVsdGlwbGU6IGJvb2xlYW4gPSB0cnVlXG4gIEBPdXRwdXQoKSBvblRyZWVTZWxlY3Q6IEV2ZW50RW1pdHRlcjxEeW5hbWljRmxhdE5vZGVbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPER5bmFtaWNGbGF0Tm9kZVtdPigpXG5cbiAgZGF0YVNvdXJjZSE6IFRyZWVEYXRhU291cmNlO1xuICBzZWxlY3RlZE5vZGU6IGFueTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KFRSRUVfU0VSVklDRSkgcHVibGljIHRyZWVTZXJ2aWNlOiBUcmVlU2VydmljZVxuICApIHsgfVxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmRhdGFTb3VyY2UgPSBuZXcgVHJlZURhdGFTb3VyY2UodGhpcy50cmVlQ29udHJvbCwgdGhpcy50cmVlU2VydmljZSk7XG4gICAgdGhpcy50cmVlU2VydmljZS5pbml0aWFsRGF0YSgpLnN1YnNjcmliZShyZXMgPT4ge1xuICAgICAgdGhpcy5kYXRhU291cmNlLmRhdGEgPSByZXNcbiAgICB9KVxuICB9XG5cbiAgaGFzQ2hpbGQgPSAoXzogbnVtYmVyLCBub2RlOiBEeW5hbWljRmxhdE5vZGUpID0+IG5vZGUuZXhwYW5kYWJsZTtcblxuXG4gIHRyZWVDb250cm9sID0gbmV3IEZsYXRUcmVlQ29udHJvbDxhbnk+KFxuICAgIChub2RlKSA9PiBub2RlLmxldmVsLFxuICAgIChub2RlKSA9PiBub2RlLmV4cGFuZGFibGVcbiAgKTtcblxufVxuIiwiPG1hdC10cmVlIFtkYXRhU291cmNlXT1cImRhdGFTb3VyY2VcIiBbdHJlZUNvbnRyb2xdPVwidHJlZUNvbnRyb2xcIj5cbiAgICA8bWF0LXRyZWUtbm9kZSAqbWF0VHJlZU5vZGVEZWY9XCJsZXQgbm9kZVwiIG1hdFRyZWVOb2RlUGFkZGluZz5cbiAgICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIGRpc2FibGVkPjwvYnV0dG9uPlxuICAgICAgPHNwYW4gW2NsYXNzXT1cIlxuICAgICAgICAgIHNlbGVjdGVkTm9kZSA9PT0gbm9kZS51cmxcbiAgICAgICAgICAgID8gJ25vcm1sLXRyZWUtbm9kZSBzZWxlY3RlZC1ub3JtbC10cmVlLW5vZGUnXG4gICAgICAgICAgICA6ICdub3JtbC10cmVlLW5vZGUnXG4gICAgICAgIFwiIFtyb3V0ZXJMaW5rXT1cIm5vZGUudXJsXCIgKGNsaWNrKT1cInNlbGVjdGVkTm9kZSA9IG5vZGUudXJsXCI+e3sgbm9kZS5uYW1lIH19PC9zcGFuPlxuICAgIDwvbWF0LXRyZWUtbm9kZT5cblxuICAgIDxtYXQtdHJlZS1ub2RlICptYXRUcmVlTm9kZURlZj1cImxldCBub2RlOyB3aGVuOiBoYXNDaGlsZFwiIG1hdFRyZWVOb2RlUGFkZGluZz5cbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG1hdC1pY29uLWJ1dHRvbiBtYXRUcmVlTm9kZVRvZ2dsZSBbZGlzYWJsZWRdPVwibm9kZS5pc0xvYWRpbmdcIj5cbiAgICAgICAgPG1hdC1pY29uPlxuICAgICAgICAgIHt7IHRyZWVDb250cm9sLmlzRXhwYW5kZWQobm9kZSkgPyAnZXhwYW5kX21vcmUnIDogJ2NoZXZyb25fcmlnaHQnIH19XG4gICAgICAgIDwvbWF0LWljb24+XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwicy1saW5rXCI+e3sgbm9kZS5uYW1lIH19PC9zcGFuPlxuXG4gICAgICA8bWF0LXNwaW5uZXIgKm5nSWY9XCJub2RlLmlzTG9hZGluZ1wiIFtkaWFtZXRlcl09XCIxOFwiPjwvbWF0LXNwaW5uZXI+XG4gICAgICAgICAgICA8ZGl2IFtjbGFzcy5leGFtcGxlLXRyZWUtaW52aXNpYmxlXT1cIiF0cmVlQ29udHJvbC5pc0V4cGFuZGVkKG5vZGUpXCIgcm9sZT1cImdyb3VwXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgbWF0VHJlZU5vZGVPdXRsZXQ+PC9uZy1jb250YWluZXI+XG4gICAgICA8L2Rpdj5cbiAgICA8L21hdC10cmVlLW5vZGU+XG4gIDwvbWF0LXRyZWU+XG4iXX0=
import { FlatTreeControl } from '@angular/cdk/tree';
import { Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { TreeDataSource, TREE_SERVICE } from './dynamic-data-source';
import { SelectionModel } from '@angular/cdk/collections';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/router";
import * as i3 from "@angular/material/tree";
import * as i4 from "@angular/material/icon";
import * as i5 from "@angular/material/progress-spinner";
import * as i6 from "@angular/material/button";
import * as i7 from "@angular/cdk/drag-drop";
/***
 * 可以进行排序的树，整体管理
 */
export class SortableTreeComponent {
    constructor(treeService) {
        this.treeService = treeService;
        this.multiple = true;
        this.onTreeSelect = new EventEmitter();
        this.hasChild = (_, node) => node.expandable;
        this.treeControl = new FlatTreeControl((node) => node.level, (node) => node.expandable);
        this.dragging = false;
        this.expandDelay = 1000;
        this.validateDrop = false;
        this.expansionModel = new SelectionModel(true);
    }
    ngOnInit() {
        console.log(this.treeService);
        this.dataSource = new TreeDataSource(this.treeControl, this.treeService);
        this.treeService.initialData().subscribe(res => {
            this.dataSource.data = res;
        });
    }
    drop(event) {
        console.log('origin/destination', event.previousIndex, event.currentIndex, event);
        // ignore drops outside of the tree
        if (!event.isPointerOverContainer)
            return;
        // deep clone the data source so we can mutate it
        const changedData = JSON.parse(JSON.stringify(this.dataSource.data));
        const node_ = changedData[event.previousIndex];
        const nodeAtDest = this.dataSource.data[event.currentIndex];
        if (node_.parentId !== nodeAtDest.parentId) {
            alert('仅允许同一层级排序');
            return;
        }
        // recursive find function to find siblings of node
        function findNodeSiblings(arr, id) {
            let result, subResult;
            arr.forEach((item, i) => {
                if (item.id === id) {
                    result = arr;
                }
                else if (item.children) {
                    subResult = findNodeSiblings(item.children, id);
                    if (subResult)
                        result = subResult;
                }
            });
            return result;
        }
        // determine where to insert the node
        const newSiblings = findNodeSiblings(changedData, nodeAtDest?.id);
        if (!newSiblings)
            return;
        const insertIndex = newSiblings.findIndex((s) => s.id === nodeAtDest?.id);
        // remove the node from its old place
        const node = event.item.data;
        const siblings = findNodeSiblings(changedData, node.id);
        const siblingIndex = siblings?.findIndex((n) => n.id === node.id);
        const nodeToInsert = siblings?.splice(siblingIndex, 1)[0];
        if (nodeAtDest.id === nodeToInsert.id)
            return;
        // insert node
        newSiblings.splice(insertIndex, 0, nodeToInsert);
        this.treeService.move(node_.id, nodeAtDest?.id).subscribe(() => {
            this.rebuildTreeForData(changedData);
        });
        // rebuild tree with mutated data
        // this.rebuildTreeForData(changedData);
    }
    rebuildTreeForData(data) {
        this.dataSource.data = data;
        this.expansionModel.selected.forEach((id) => {
            const node = this.treeControl.dataNodes.find((n) => n.id === id);
            node.sorting = true;
            this.treeControl.expand(node);
        });
        // this.treeService.initialData().subscribe(res => {
        //   this.dataSource.data = res
        //   this.expansionModel.selected.forEach((id) => {
        //     const node = this.treeControl.dataNodes.find((n) => n.id === id);
        //     this.treeControl.expand(node);
        //   });
        // })
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SortableTreeComponent, deps: [{ token: TREE_SERVICE }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SortableTreeComponent, selector: "spr-sortable-tree", inputs: { multiple: "multiple" }, outputs: { onTreeSelect: "onTreeSelect" }, ngImport: i0, template: "<mat-tree\n  [dataSource]=\"dataSource\"\n  [treeControl]=\"treeControl\"\n  [cdkDropListData]=\"dataSource.data\"\n  cdkDropList\n  (cdkDropListDropped)=\"drop($event)\"\n>\n  <mat-tree-node\n    *matTreeNodeDef=\"let node\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button mat-icon-button disabled></button>\n    <span\n      [class]=\"\n        selectedNode === node.url\n          ? 'norml-tree-node selected-norml-tree-node'\n          : 'norml-tree-node'\n      \"\n      [routerLink]=\"node.url\"\n      (click)=\"selectedNode = node.url\"\n      >{{ node.name }}</span\n    >\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n  </mat-tree-node>\n\n  <mat-tree-node\n    *matTreeNodeDef=\"let node; when: hasChild\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button\n      type=\"button\"\n      mat-icon-button\n      matTreeNodeToggle\n      [disabled]=\"node.isLoading\"\n      (click)=\"expansionModel.toggle(node.id)\"\n    >\n      <mat-icon>\n        {{ treeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\n      </mat-icon>\n    </button>\n    <span class=\"s-link\">{{ node.name }}</span>\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n    <mat-spinner *ngIf=\"node.isLoading\" [diameter]=\"18\"></mat-spinner>\n    <div\n      [class.example-tree-invisible]=\"!treeControl.isExpanded(node)\"\n      role=\"group\"\n    >\n      <ng-container matTreeNodeOutlet></ng-container>\n    </div>\n  </mat-tree-node>\n</mat-tree>\n", styles: [""], dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: i3.MatTreeNodeDef, selector: "[matTreeNodeDef]", inputs: ["matTreeNodeDefWhen", "matTreeNode"] }, { kind: "directive", type: i3.MatTreeNodePadding, selector: "[matTreeNodePadding]", inputs: ["matTreeNodePadding", "matTreeNodePaddingIndent"] }, { kind: "directive", type: i3.MatTreeNodeToggle, selector: "[matTreeNodeToggle]", inputs: ["matTreeNodeToggleRecursive"] }, { kind: "component", type: i3.MatTree, selector: "mat-tree", exportAs: ["matTree"] }, { kind: "directive", type: i3.MatTreeNode, selector: "mat-tree-node", inputs: ["role", "disabled", "tabIndex"], exportAs: ["matTreeNode"] }, { kind: "directive", type: i3.MatTreeNodeOutlet, selector: "[matTreeNodeOutlet]" }, { kind: "component", type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i5.MatProgressSpinner, selector: "mat-progress-spinner, mat-spinner", inputs: ["color", "mode", "value", "diameter", "strokeWidth"], exportAs: ["matProgressSpinner"] }, { kind: "component", type: i6.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i7.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "cdkDropListData", "cdkDropListOrientation", "id", "cdkDropListLockAxis", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListAutoScrollDisabled", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { kind: "directive", type: i7.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragData", "cdkDragLockAxis", "cdkDragRootElement", "cdkDragBoundary", "cdkDragStartDelay", "cdkDragFreeDragPosition", "cdkDragDisabled", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragPreviewContainer"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { kind: "directive", type: i7.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SortableTreeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'spr-sortable-tree', template: "<mat-tree\n  [dataSource]=\"dataSource\"\n  [treeControl]=\"treeControl\"\n  [cdkDropListData]=\"dataSource.data\"\n  cdkDropList\n  (cdkDropListDropped)=\"drop($event)\"\n>\n  <mat-tree-node\n    *matTreeNodeDef=\"let node\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button mat-icon-button disabled></button>\n    <span\n      [class]=\"\n        selectedNode === node.url\n          ? 'norml-tree-node selected-norml-tree-node'\n          : 'norml-tree-node'\n      \"\n      [routerLink]=\"node.url\"\n      (click)=\"selectedNode = node.url\"\n      >{{ node.name }}</span\n    >\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n  </mat-tree-node>\n\n  <mat-tree-node\n    *matTreeNodeDef=\"let node; when: hasChild\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button\n      type=\"button\"\n      mat-icon-button\n      matTreeNodeToggle\n      [disabled]=\"node.isLoading\"\n      (click)=\"expansionModel.toggle(node.id)\"\n    >\n      <mat-icon>\n        {{ treeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\n      </mat-icon>\n    </button>\n    <span class=\"s-link\">{{ node.name }}</span>\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n    <mat-spinner *ngIf=\"node.isLoading\" [diameter]=\"18\"></mat-spinner>\n    <div\n      [class.example-tree-invisible]=\"!treeControl.isExpanded(node)\"\n      role=\"group\"\n    >\n      <ng-container matTreeNodeOutlet></ng-container>\n    </div>\n  </mat-tree-node>\n</mat-tree>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [TREE_SERVICE]
                }] }]; }, propDecorators: { multiple: [{
                type: Input
            }], onTreeSelect: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydGFibGUtdHJlZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb21tb24tdWktbm0vc3JjL2xpYi90cmVlL3NvcnRhYmxlLXRyZWUvc29ydGFibGUtdHJlZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb21tb24tdWktbm0vc3JjL2xpYi90cmVlL3NvcnRhYmxlLXRyZWUvc29ydGFibGUtdHJlZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFcEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDL0UsT0FBTyxFQUFFLGNBQWMsRUFBa0IsWUFBWSxFQUFlLE1BQU0sdUJBQXVCLENBQUM7QUFDbEcsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDOzs7Ozs7Ozs7QUFHMUQ7O0dBRUc7QUFPSCxNQUFNLE9BQU8scUJBQXFCO0lBT2hDLFlBQytCLFdBQXdCO1FBQXhCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBUDlDLGFBQVEsR0FBWSxJQUFJLENBQUE7UUFDdkIsaUJBQVksR0FBb0MsSUFBSSxZQUFZLEVBQXFCLENBQUE7UUFnQi9GLGFBQVEsR0FBRyxDQUFDLENBQVMsRUFBRSxJQUFxQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBR2pFLGdCQUFXLEdBQUcsSUFBSSxlQUFlLENBQy9CLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUNwQixDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FDMUIsQ0FBQztRQUlGLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFFakIs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NkRBOzs0RkQ3Q2EscUJBQXFCO2tCQUxqQyxTQUFTOytCQUNFLG1CQUFtQjs7MEJBWTFCLE1BQU07MkJBQUMsWUFBWTs0Q0FQYixRQUFRO3NCQUFoQixLQUFLO2dCQUNJLFlBQVk7c0JBQXJCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGbGF0VHJlZUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9jZGsvdHJlZSc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHJlZURhdGFTb3VyY2UsRHluYW1pY0ZsYXROb2RlLCBUUkVFX1NFUlZJQ0UsIFRyZWVTZXJ2aWNlIH0gZnJvbSAnLi9keW5hbWljLWRhdGEtc291cmNlJztcbmltcG9ydCB7IFNlbGVjdGlvbk1vZGVsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcbmltcG9ydCB7IENka0RyYWdEcm9wIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2RyYWctZHJvcCc7XG5cbi8qKipcbiAqIOWPr+S7pei/m+ihjOaOkuW6j+eahOagke+8jOaVtOS9k+euoeeQhlxuICovXG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3Nwci1zb3J0YWJsZS10cmVlJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3NvcnRhYmxlLXRyZWUuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9zb3J0YWJsZS10cmVlLmNvbXBvbmVudC5jc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBTb3J0YWJsZVRyZWVDb21wb25lbnQge1xuICBASW5wdXQoKSBtdWx0aXBsZTogYm9vbGVhbiA9IHRydWVcbiAgQE91dHB1dCgpIG9uVHJlZVNlbGVjdDogRXZlbnRFbWl0dGVyPER5bmFtaWNGbGF0Tm9kZVtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8RHluYW1pY0ZsYXROb2RlW10+KClcblxuICBkYXRhU291cmNlITogVHJlZURhdGFTb3VyY2U7XG4gIHNlbGVjdGVkTm9kZTogYW55O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoVFJFRV9TRVJWSUNFKSBwdWJsaWMgdHJlZVNlcnZpY2U6IFRyZWVTZXJ2aWNlXG4gICkgeyB9XG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKHRoaXMudHJlZVNlcnZpY2UpXG4gICAgdGhpcy5kYXRhU291cmNlID0gbmV3IFRyZWVEYXRhU291cmNlKHRoaXMudHJlZUNvbnRyb2wsIHRoaXMudHJlZVNlcnZpY2UpO1xuICAgIHRoaXMudHJlZVNlcnZpY2UuaW5pdGlhbERhdGEoKS5zdWJzY3JpYmUocmVzID0+IHtcbiAgICAgIHRoaXMuZGF0YVNvdXJjZS5kYXRhID0gcmVzXG4gICAgfSlcbiAgfVxuXG4gIGhhc0NoaWxkID0gKF86IG51bWJlciwgbm9kZTogRHluYW1pY0ZsYXROb2RlKSA9PiBub2RlLmV4cGFuZGFibGU7XG5cblxuICB0cmVlQ29udHJvbCA9IG5ldyBGbGF0VHJlZUNvbnRyb2w8YW55PihcbiAgICAobm9kZSkgPT4gbm9kZS5sZXZlbCxcbiAgICAobm9kZSkgPT4gbm9kZS5leHBhbmRhYmxlXG4gICk7XG5cblxuXG4gIGRyYWdnaW5nID0gZmFsc2U7XG4gIGV4cGFuZFRpbWVvdXQ6IGFueTtcbiAgZXhwYW5kRGVsYXkgPSAxMDAwO1xuICB2YWxpZGF0ZURyb3AgPSBmYWxzZTtcbiAgZXhwYW5zaW9uTW9kZWwgPSBuZXcgU2VsZWN0aW9uTW9kZWw8c3RyaW5nPih0cnVlKTtcbiAgZHJvcChldmVudDogYW55KSB7XG4gICAgY29uc29sZS5sb2coJ29yaWdpbi9kZXN0aW5hdGlvbicsIGV2ZW50LnByZXZpb3VzSW5kZXgsIGV2ZW50LmN1cnJlbnRJbmRleCwgZXZlbnQpO1xuXG4gICAgLy8gaWdub3JlIGRyb3BzIG91dHNpZGUgb2YgdGhlIHRyZWVcbiAgICBpZiAoIWV2ZW50LmlzUG9pbnRlck92ZXJDb250YWluZXIpIHJldHVybjtcblxuICAgIC8vIGRlZXAgY2xvbmUgdGhlIGRhdGEgc291cmNlIHNvIHdlIGNhbiBtdXRhdGUgaXRcbiAgICBjb25zdCBjaGFuZ2VkRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhU291cmNlLmRhdGEpKTtcbiAgICBjb25zdCBub2RlXyA9IGNoYW5nZWREYXRhW2V2ZW50LnByZXZpb3VzSW5kZXhdXG4gICAgY29uc3Qgbm9kZUF0RGVzdDogYW55ID0gdGhpcy5kYXRhU291cmNlLmRhdGFbZXZlbnQuY3VycmVudEluZGV4XTtcbiAgICBpZiAobm9kZV8ucGFyZW50SWQgIT09IG5vZGVBdERlc3QucGFyZW50SWQpIHtcbiAgICAgIGFsZXJ0KCfku4XlhYHorrjlkIzkuIDlsYLnuqfmjpLluo8nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcmVjdXJzaXZlIGZpbmQgZnVuY3Rpb24gdG8gZmluZCBzaWJsaW5ncyBvZiBub2RlXG4gICAgZnVuY3Rpb24gZmluZE5vZGVTaWJsaW5ncyhcbiAgICAgIGFycjogQXJyYXk8YW55PixcbiAgICAgIGlkOiBzdHJpbmdcbiAgICApOiBBcnJheTxhbnk+IHwgdW5kZWZpbmVkIHtcbiAgICAgIGxldCByZXN1bHQsIHN1YlJlc3VsdDtcbiAgICAgIGFyci5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLmlkID09PSBpZCkge1xuICAgICAgICAgIHJlc3VsdCA9IGFycjtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgc3ViUmVzdWx0ID0gZmluZE5vZGVTaWJsaW5ncyhpdGVtLmNoaWxkcmVuLCBpZCk7XG4gICAgICAgICAgaWYgKHN1YlJlc3VsdCkgcmVzdWx0ID0gc3ViUmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIHdoZXJlIHRvIGluc2VydCB0aGUgbm9kZVxuXG4gICAgY29uc3QgbmV3U2libGluZ3MgPSBmaW5kTm9kZVNpYmxpbmdzKGNoYW5nZWREYXRhLCBub2RlQXREZXN0Py5pZCk7XG4gICAgaWYgKCFuZXdTaWJsaW5ncykgcmV0dXJuO1xuICAgIGNvbnN0IGluc2VydEluZGV4ID0gbmV3U2libGluZ3MuZmluZEluZGV4KChzKSA9PiBzLmlkID09PSBub2RlQXREZXN0Py5pZCk7XG5cbiAgICAvLyByZW1vdmUgdGhlIG5vZGUgZnJvbSBpdHMgb2xkIHBsYWNlXG4gICAgY29uc3Qgbm9kZSA9IGV2ZW50Lml0ZW0uZGF0YTtcbiAgICBjb25zdCBzaWJsaW5ncyA9IGZpbmROb2RlU2libGluZ3MoY2hhbmdlZERhdGEsIG5vZGUuaWQpO1xuICAgIGNvbnN0IHNpYmxpbmdJbmRleCA9IHNpYmxpbmdzPy5maW5kSW5kZXgoKG4pID0+IG4uaWQgPT09IG5vZGUuaWQpO1xuICAgIGNvbnN0IG5vZGVUb0luc2VydDogYW55ID0gc2libGluZ3M/LnNwbGljZShzaWJsaW5nSW5kZXghLCAxKVswXTtcbiAgICBpZiAobm9kZUF0RGVzdC5pZCA9PT0gbm9kZVRvSW5zZXJ0LmlkKSByZXR1cm47XG5cbiAgICAvLyBpbnNlcnQgbm9kZVxuICAgIG5ld1NpYmxpbmdzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgbm9kZVRvSW5zZXJ0KTtcblxuICAgIHRoaXMudHJlZVNlcnZpY2UubW92ZShub2RlXy5pZCwgbm9kZUF0RGVzdD8uaWQpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlYnVpbGRUcmVlRm9yRGF0YShjaGFuZ2VkRGF0YSk7XG4gICAgfSlcbiAgICAvLyByZWJ1aWxkIHRyZWUgd2l0aCBtdXRhdGVkIGRhdGFcbiAgICAvLyB0aGlzLnJlYnVpbGRUcmVlRm9yRGF0YShjaGFuZ2VkRGF0YSk7XG4gIH1cblxuICByZWJ1aWxkVHJlZUZvckRhdGEoZGF0YTogYW55KSB7XG4gICAgdGhpcy5kYXRhU291cmNlLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZXhwYW5zaW9uTW9kZWwuc2VsZWN0ZWQuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnRyZWVDb250cm9sLmRhdGFOb2Rlcy5maW5kKChuKSA9PiBuLmlkID09PSBpZCk7XG4gICAgICBub2RlLnNvcnRpbmc9dHJ1ZVxuICAgICAgdGhpcy50cmVlQ29udHJvbC5leHBhbmQobm9kZSk7XG4gICAgfSk7XG5cbiAgICAvLyB0aGlzLnRyZWVTZXJ2aWNlLmluaXRpYWxEYXRhKCkuc3Vic2NyaWJlKHJlcyA9PiB7XG4gICAgLy8gICB0aGlzLmRhdGFTb3VyY2UuZGF0YSA9IHJlc1xuICAgIC8vICAgdGhpcy5leHBhbnNpb25Nb2RlbC5zZWxlY3RlZC5mb3JFYWNoKChpZCkgPT4ge1xuICAgIC8vICAgICBjb25zdCBub2RlID0gdGhpcy50cmVlQ29udHJvbC5kYXRhTm9kZXMuZmluZCgobikgPT4gbi5pZCA9PT0gaWQpO1xuICAgIC8vICAgICB0aGlzLnRyZWVDb250cm9sLmV4cGFuZChub2RlKTtcbiAgICAvLyAgIH0pO1xuICAgIC8vIH0pXG5cblxuICB9XG5cbn1cbiIsIjxtYXQtdHJlZVxuICBbZGF0YVNvdXJjZV09XCJkYXRhU291cmNlXCJcbiAgW3RyZWVDb250cm9sXT1cInRyZWVDb250cm9sXCJcbiAgW2Nka0Ryb3BMaXN0RGF0YV09XCJkYXRhU291cmNlLmRhdGFcIlxuICBjZGtEcm9wTGlzdFxuICAoY2RrRHJvcExpc3REcm9wcGVkKT1cImRyb3AoJGV2ZW50KVwiXG4+XG4gIDxtYXQtdHJlZS1ub2RlXG4gICAgKm1hdFRyZWVOb2RlRGVmPVwibGV0IG5vZGVcIlxuICAgIG1hdFRyZWVOb2RlUGFkZGluZ1xuICAgIFtjZGtEcmFnRGF0YV09XCJub2RlXCJcbiAgICBjZGtEcmFnTG9ja0F4aXM9XCJ5XCJcbiAgICBjZGtEcmFnXG4gID5cbiAgICA8YnV0dG9uIG1hdC1pY29uLWJ1dHRvbiBkaXNhYmxlZD48L2J1dHRvbj5cbiAgICA8c3BhblxuICAgICAgW2NsYXNzXT1cIlxuICAgICAgICBzZWxlY3RlZE5vZGUgPT09IG5vZGUudXJsXG4gICAgICAgICAgPyAnbm9ybWwtdHJlZS1ub2RlIHNlbGVjdGVkLW5vcm1sLXRyZWUtbm9kZSdcbiAgICAgICAgICA6ICdub3JtbC10cmVlLW5vZGUnXG4gICAgICBcIlxuICAgICAgW3JvdXRlckxpbmtdPVwibm9kZS51cmxcIlxuICAgICAgKGNsaWNrKT1cInNlbGVjdGVkTm9kZSA9IG5vZGUudXJsXCJcbiAgICAgID57eyBub2RlLm5hbWUgfX08L3NwYW5cbiAgICA+XG4gICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gY2RrRHJhZ0xvY2tBeGlzPVwieVwiIGNka0RyYWdIYW5kbGU+XG4gICAgICA8bWF0LWljb24+ZHJhZ19pbmRpY2F0b3I8L21hdC1pY29uPlxuICAgIDwvYnV0dG9uPlxuICA8L21hdC10cmVlLW5vZGU+XG5cbiAgPG1hdC10cmVlLW5vZGVcbiAgICAqbWF0VHJlZU5vZGVEZWY9XCJsZXQgbm9kZTsgd2hlbjogaGFzQ2hpbGRcIlxuICAgIG1hdFRyZWVOb2RlUGFkZGluZ1xuICAgIFtjZGtEcmFnRGF0YV09XCJub2RlXCJcbiAgICBjZGtEcmFnTG9ja0F4aXM9XCJ5XCJcbiAgICBjZGtEcmFnXG4gID5cbiAgICA8YnV0dG9uXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIG1hdC1pY29uLWJ1dHRvblxuICAgICAgbWF0VHJlZU5vZGVUb2dnbGVcbiAgICAgIFtkaXNhYmxlZF09XCJub2RlLmlzTG9hZGluZ1wiXG4gICAgICAoY2xpY2spPVwiZXhwYW5zaW9uTW9kZWwudG9nZ2xlKG5vZGUuaWQpXCJcbiAgICA+XG4gICAgICA8bWF0LWljb24+XG4gICAgICAgIHt7IHRyZWVDb250cm9sLmlzRXhwYW5kZWQobm9kZSkgPyBcImV4cGFuZF9tb3JlXCIgOiBcImNoZXZyb25fcmlnaHRcIiB9fVxuICAgICAgPC9tYXQtaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgICA8c3BhbiBjbGFzcz1cInMtbGlua1wiPnt7IG5vZGUubmFtZSB9fTwvc3Bhbj5cbiAgICA8YnV0dG9uIG1hdC1pY29uLWJ1dHRvbiBjZGtEcmFnTG9ja0F4aXM9XCJ5XCIgY2RrRHJhZ0hhbmRsZT5cbiAgICAgIDxtYXQtaWNvbj5kcmFnX2luZGljYXRvcjwvbWF0LWljb24+XG4gICAgPC9idXR0b24+XG4gICAgPG1hdC1zcGlubmVyICpuZ0lmPVwibm9kZS5pc0xvYWRpbmdcIiBbZGlhbWV0ZXJdPVwiMThcIj48L21hdC1zcGlubmVyPlxuICAgIDxkaXZcbiAgICAgIFtjbGFzcy5leGFtcGxlLXRyZWUtaW52aXNpYmxlXT1cIiF0cmVlQ29udHJvbC5pc0V4cGFuZGVkKG5vZGUpXCJcbiAgICAgIHJvbGU9XCJncm91cFwiXG4gICAgPlxuICAgICAgPG5nLWNvbnRhaW5lciBtYXRUcmVlTm9kZU91dGxldD48L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbiAgPC9tYXQtdHJlZS1ub2RlPlxuPC9tYXQtdHJlZT5cbiJdfQ==
import { FlatTreeControl } from '@angular/cdk/tree';
import { Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { SelectionModel } from '@angular/cdk/collections';
import { TREE_SERVICE, TreeDataSource } from './dynamic-data-source';
import { ChecklistSelectionService } from '../checklist-selection.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/router";
import * as i3 from "@angular/material/checkbox";
import * as i4 from "@angular/material/tree";
import * as i5 from "@angular/material/icon";
import * as i6 from "@angular/material/progress-spinner";
import * as i7 from "@angular/material/button";
import * as i8 from "@angular/cdk/drag-drop";
/***
 * 可以进行排序的树，整体管理
 */
export class SortableTreeComponent {
    onToggle(node) {
        this.checklistSelectionService.toggleSelection(node, this.dataSource.nodeCache);
        this.onTreeSelect?.emit(this.checklistSelectionService.selected.selected.map(m => m.id));
    }
    constructor(treeService) {
        this.treeService = treeService;
        this.multiple = true;
        this.initSelected = [];
        this.onTreeSelect = new EventEmitter();
        this.hasChild = (_, node) => node.expandable;
        this.treeControl = new FlatTreeControl((node) => node.level, (node) => node.expandable);
        this.dragging = false;
        this.expandDelay = 1000;
        this.validateDrop = false;
        this.expansionModel = new SelectionModel(true);
    }
    ngOnInit() {
        this.checklistSelectionService = new ChecklistSelectionService(this.multiple);
        this.initSelected.forEach(f => this.checklistSelectionService.selected.select(f));
        this.dataSource = new TreeDataSource(this.treeControl, this.treeService);
        this.treeService.initialData().subscribe(res => {
            this.dataSource.data = res;
        });
    }
    drop(event) {
        console.log('origin/destination', event.previousIndex, event.currentIndex, event);
        // ignore drops outside of the tree
        if (!event.isPointerOverContainer)
            return;
        // deep clone the data source so we can mutate it
        const changedData = JSON.parse(JSON.stringify(this.dataSource.data));
        const node_ = changedData[event.previousIndex];
        const nodeAtDest = this.dataSource.data[event.currentIndex];
        if (node_.parentId !== nodeAtDest.parentId) {
            alert('仅允许同一层级排序');
            return;
        }
        // recursive find function to find siblings of node
        function findNodeSiblings(arr, id) {
            let result, subResult;
            arr.forEach((item, i) => {
                if (item.id === id) {
                    result = arr;
                }
                else if (item.children) {
                    subResult = findNodeSiblings(item.children, id);
                    if (subResult)
                        result = subResult;
                }
            });
            return result;
        }
        // determine where to insert the node
        const newSiblings = findNodeSiblings(changedData, nodeAtDest?.id);
        if (!newSiblings)
            return;
        const insertIndex = newSiblings.findIndex((s) => s.id === nodeAtDest?.id);
        // remove the node from its old place
        const node = event.item.data;
        const siblings = findNodeSiblings(changedData, node.id);
        const siblingIndex = siblings?.findIndex((n) => n.id === node.id);
        const nodeToInsert = siblings?.splice(siblingIndex, 1)[0];
        if (nodeAtDest.id === nodeToInsert.id)
            return;
        // insert node
        newSiblings.splice(insertIndex, 0, nodeToInsert);
        this.treeService.move(node_.id, nodeAtDest?.id).subscribe(() => {
            this.rebuildTreeForData(changedData);
        });
        // rebuild tree with mutated data
        // this.rebuildTreeForData(changedData);
    }
    rebuildTreeForData(data) {
        this.dataSource.data = data;
        this.expansionModel.selected.forEach((id) => {
            const node = this.treeControl.dataNodes.find((n) => n.id === id);
            node.sorting = true;
            this.treeControl.expand(node);
        });
        // this.treeService.initialData().subscribe(res => {
        //   this.dataSource.data = res
        //   this.expansionModel.selected.forEach((id) => {
        //     const node = this.treeControl.dataNodes.find((n) => n.id === id);
        //     this.treeControl.expand(node);
        //   });
        // })
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SortableTreeComponent, deps: [{ token: TREE_SERVICE }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SortableTreeComponent, selector: "spr-sortable-tree", inputs: { multiple: "multiple", initSelected: "initSelected" }, outputs: { onTreeSelect: "onTreeSelect" }, ngImport: i0, template: "<mat-tree\n  [dataSource]=\"dataSource\"\n  [treeControl]=\"treeControl\"\n  [cdkDropListData]=\"dataSource.data\"\n  cdkDropList\n  (cdkDropListDropped)=\"drop($event)\"\n>\n  <mat-tree-node\n    *matTreeNodeDef=\"let node\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button mat-icon-button disabled></button>\n    <mat-checkbox\n      [checked]=\"checklistSelectionService.isSelected(node)\"\n      (change)=\"onToggle(node)\"\n    ></mat-checkbox>\n    <span\n      [class]=\"\n        selectedNode === node.url\n          ? 'norml-tree-node selected-norml-tree-node'\n          : 'norml-tree-node'\n      \"\n      [routerLink]=\"node.url\"\n      (click)=\"selectedNode = node.url\"\n      >{{ node.name }}</span\n    >\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n  </mat-tree-node>\n\n  <mat-tree-node\n    *matTreeNodeDef=\"let node; when: hasChild\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button\n      type=\"button\"\n      mat-icon-button\n      matTreeNodeToggle\n      [disabled]=\"node.isLoading\"\n      (click)=\"expansionModel.toggle(node.id)\"\n    >\n      <mat-icon>\n        {{ treeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\n      </mat-icon>\n    </button>\n    <mat-checkbox\n      [checked]=\"checklistSelectionService.isSelected(node)\"\n      [indeterminate]=\"node.indeterminate\"\n      (change)=\"onToggle(node)\"\n    ></mat-checkbox>\n    <span class=\"s-link\">{{ node.name }}</span>\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n    <mat-spinner *ngIf=\"node.isLoading\" [diameter]=\"18\"></mat-spinner>\n    <div\n      [class.example-tree-invisible]=\"!treeControl.isExpanded(node)\"\n      role=\"group\"\n    >\n      <ng-container matTreeNodeOutlet></ng-container>\n    </div>\n  </mat-tree-node>\n</mat-tree>\n", styles: [""], dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "component", type: i3.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex"], exportAs: ["matCheckbox"] }, { kind: "directive", type: i4.MatTreeNodeDef, selector: "[matTreeNodeDef]", inputs: ["matTreeNodeDefWhen", "matTreeNode"] }, { kind: "directive", type: i4.MatTreeNodePadding, selector: "[matTreeNodePadding]", inputs: ["matTreeNodePadding", "matTreeNodePaddingIndent"] }, { kind: "directive", type: i4.MatTreeNodeToggle, selector: "[matTreeNodeToggle]", inputs: ["matTreeNodeToggleRecursive"] }, { kind: "component", type: i4.MatTree, selector: "mat-tree", exportAs: ["matTree"] }, { kind: "directive", type: i4.MatTreeNode, selector: "mat-tree-node", inputs: ["role", "disabled", "tabIndex"], exportAs: ["matTreeNode"] }, { kind: "directive", type: i4.MatTreeNodeOutlet, selector: "[matTreeNodeOutlet]" }, { kind: "component", type: i5.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i6.MatProgressSpinner, selector: "mat-progress-spinner, mat-spinner", inputs: ["color", "mode", "value", "diameter", "strokeWidth"], exportAs: ["matProgressSpinner"] }, { kind: "component", type: i7.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i8.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "cdkDropListData", "cdkDropListOrientation", "id", "cdkDropListLockAxis", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListAutoScrollDisabled", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { kind: "directive", type: i8.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragData", "cdkDragLockAxis", "cdkDragRootElement", "cdkDragBoundary", "cdkDragStartDelay", "cdkDragFreeDragPosition", "cdkDragDisabled", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragPreviewContainer"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { kind: "directive", type: i8.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SortableTreeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'spr-sortable-tree', template: "<mat-tree\n  [dataSource]=\"dataSource\"\n  [treeControl]=\"treeControl\"\n  [cdkDropListData]=\"dataSource.data\"\n  cdkDropList\n  (cdkDropListDropped)=\"drop($event)\"\n>\n  <mat-tree-node\n    *matTreeNodeDef=\"let node\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button mat-icon-button disabled></button>\n    <mat-checkbox\n      [checked]=\"checklistSelectionService.isSelected(node)\"\n      (change)=\"onToggle(node)\"\n    ></mat-checkbox>\n    <span\n      [class]=\"\n        selectedNode === node.url\n          ? 'norml-tree-node selected-norml-tree-node'\n          : 'norml-tree-node'\n      \"\n      [routerLink]=\"node.url\"\n      (click)=\"selectedNode = node.url\"\n      >{{ node.name }}</span\n    >\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n  </mat-tree-node>\n\n  <mat-tree-node\n    *matTreeNodeDef=\"let node; when: hasChild\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button\n      type=\"button\"\n      mat-icon-button\n      matTreeNodeToggle\n      [disabled]=\"node.isLoading\"\n      (click)=\"expansionModel.toggle(node.id)\"\n    >\n      <mat-icon>\n        {{ treeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\n      </mat-icon>\n    </button>\n    <mat-checkbox\n      [checked]=\"checklistSelectionService.isSelected(node)\"\n      [indeterminate]=\"node.indeterminate\"\n      (change)=\"onToggle(node)\"\n    ></mat-checkbox>\n    <span class=\"s-link\">{{ node.name }}</span>\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n    <mat-spinner *ngIf=\"node.isLoading\" [diameter]=\"18\"></mat-spinner>\n    <div\n      [class.example-tree-invisible]=\"!treeControl.isExpanded(node)\"\n      role=\"group\"\n    >\n      <ng-container matTreeNodeOutlet></ng-container>\n    </div>\n  </mat-tree-node>\n</mat-tree>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [TREE_SERVICE]
                }] }]; }, propDecorators: { multiple: [{
                type: Input
            }], initSelected: [{
                type: Input
            }], onTreeSelect: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydGFibGUtdHJlZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb21tb24tdWktbm0vc3JjL2xpYi90cmVlL3NvcnRhYmxlLXRyZWUvc29ydGFibGUtdHJlZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb21tb24tdWktbm0vc3JjL2xpYi90cmVlL3NvcnRhYmxlLXRyZWUvc29ydGFibGUtdHJlZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFcEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDL0UsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRTFELE9BQU8sRUFBbUIsWUFBWSxFQUFFLGNBQWMsRUFBZSxNQUFNLHVCQUF1QixDQUFDO0FBQ25HLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDOzs7Ozs7Ozs7O0FBRTNFOztHQUVHO0FBT0gsTUFBTSxPQUFPLHFCQUFxQjtJQU1oQyxRQUFRLENBQUMsSUFBUztRQUNoQixJQUFJLENBQUMseUJBQXlCLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFBO1FBQy9FLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO0lBQzFGLENBQUM7SUFLRCxZQUMrQixXQUF3QjtRQUF4QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtR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SUFBSSxHQUFHLElBQUksQ0FBQztRQUM1QixJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRTtZQUMxQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDakUsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUE7WUFDbkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEMsQ0FBQyxDQUFDLENBQUM7UUFFSCxvREFBb0Q7UUFDcEQsK0JBQStCO1FBQy9CLG1EQUFtRDtRQUNuRCx3RUFBd0U7UUFDeEUscUNBQXFDO1FBQ3JDLFFBQVE7UUFDUixLQUFLO0lBR1AsQ0FBQzsrR0FsSFUscUJBQXFCLGtCQWV0QixZQUFZO21HQWZYLHFCQUFxQixvS0NqQmxDLDJnRUFzRUE7OzRGRHJEYSxxQkFBcUI7a0JBTGpDLFNBQVM7K0JBQ0UsbUJBQW1COzswQkFtQjFCLE1BQU07MkJBQUMsWUFBWTs0Q0FkYixRQUFRO3NCQUFoQixLQUFLO2dCQUNHLFlBQVk7c0JBQXBCLEtBQUs7Z0JBQ0ksWUFBWTtzQkFBckIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZsYXRUcmVlQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay90cmVlJztcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5qZWN0LCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25Nb2RlbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XG5pbXBvcnQgeyBDZGtEcmFnRHJvcCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9kcmFnLWRyb3AnO1xuaW1wb3J0IHsgRHluYW1pY0ZsYXROb2RlLCBUUkVFX1NFUlZJQ0UsIFRyZWVEYXRhU291cmNlLCBUcmVlU2VydmljZSB9IGZyb20gJy4vZHluYW1pYy1kYXRhLXNvdXJjZSc7XG5pbXBvcnQgeyBDaGVja2xpc3RTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vY2hlY2tsaXN0LXNlbGVjdGlvbi5zZXJ2aWNlJztcblxuLyoqKlxuICog5Y+v5Lul6L+b6KGM5o6S5bqP55qE5qCR77yM5pW05L2T566h55CGXG4gKi9cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnc3ByLXNvcnRhYmxlLXRyZWUnLFxuICB0ZW1wbGF0ZVVybDogJy4vc29ydGFibGUtdHJlZS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL3NvcnRhYmxlLXRyZWUuY29tcG9uZW50LmNzcyddXG59KVxuZXhwb3J0IGNsYXNzIFNvcnRhYmxlVHJlZUNvbXBvbmVudCB7XG4gIEBJbnB1dCgpIG11bHRpcGxlOiBib29sZWFuID0gdHJ1ZVxuICBASW5wdXQoKSBpbml0U2VsZWN0ZWQ6IGFueVtdID0gW11cbiAgQE91dHB1dCgpIG9uVHJlZVNlbGVjdDogRXZlbnRFbWl0dGVyPGFueVtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55W10+KClcblxuICBwdWJsaWMgY2hlY2tsaXN0U2VsZWN0aW9uU2VydmljZSE6IENoZWNrbGlzdFNlbGVjdGlvblNlcnZpY2VcbiAgb25Ub2dnbGUobm9kZTogYW55KSB7XG4gICAgdGhpcy5jaGVja2xpc3RTZWxlY3Rpb25TZXJ2aWNlLnRvZ2dsZVNlbGVjdGlvbihub2RlLCB0aGlzLmRhdGFTb3VyY2Uubm9kZUNhY2hlKVxuICAgIHRoaXMub25UcmVlU2VsZWN0Py5lbWl0KHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uU2VydmljZS5zZWxlY3RlZC5zZWxlY3RlZC5tYXAobSA9PiBtLmlkKSlcbiAgfVxuXG4gIGRhdGFTb3VyY2UhOiBUcmVlRGF0YVNvdXJjZTtcbiAgc2VsZWN0ZWROb2RlOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChUUkVFX1NFUlZJQ0UpIHB1YmxpYyB0cmVlU2VydmljZTogVHJlZVNlcnZpY2VcbiAgKSB7IH1cbiAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvblNlcnZpY2UgPSBuZXcgQ2hlY2tsaXN0U2VsZWN0aW9uU2VydmljZSh0aGlzLm11bHRpcGxlKVxuICAgIHRoaXMuaW5pdFNlbGVjdGVkLmZvckVhY2goZiA9PiB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0ZWQuc2VsZWN0KGYpKVxuICAgIHRoaXMuZGF0YVNvdXJjZSA9IG5ldyBUcmVlRGF0YVNvdXJjZSh0aGlzLnRyZWVDb250cm9sLCB0aGlzLnRyZWVTZXJ2aWNlKTtcbiAgICB0aGlzLnRyZWVTZXJ2aWNlLmluaXRpYWxEYXRhKCkuc3Vic2NyaWJlKHJlcyA9PiB7XG4gICAgICB0aGlzLmRhdGFTb3VyY2UuZGF0YSA9IHJlc1xuXG4gICAgfSlcbiAgfVxuXG4gIGhhc0NoaWxkID0gKF86IG51bWJlciwgbm9kZTogRHluYW1pY0ZsYXROb2RlKSA9PiBub2RlLmV4cGFuZGFibGU7XG5cblxuICB0cmVlQ29udHJvbCA9IG5ldyBGbGF0VHJlZUNvbnRyb2w8YW55PihcbiAgICAobm9kZSkgPT4gbm9kZS5sZXZlbCxcbiAgICAobm9kZSkgPT4gbm9kZS5leHBhbmRhYmxlXG4gICk7XG5cblxuXG4gIGRyYWdnaW5nID0gZmFsc2U7XG4gIGV4cGFuZFRpbWVvdXQ6IGFueTtcbiAgZXhwYW5kRGVsYXkgPSAxMDAwO1xuICB2YWxpZGF0ZURyb3AgPSBmYWxzZTtcbiAgZXhwYW5zaW9uTW9kZWwgPSBuZXcgU2VsZWN0aW9uTW9kZWw8c3RyaW5nPih0cnVlKTtcbiAgZHJvcChldmVudDogYW55KSB7XG4gICAgY29uc29sZS5sb2coJ29yaWdpbi9kZXN0aW5hdGlvbicsIGV2ZW50LnByZXZpb3VzSW5kZXgsIGV2ZW50LmN1cnJlbnRJbmRleCwgZXZlbnQpO1xuXG4gICAgLy8gaWdub3JlIGRyb3BzIG91dHNpZGUgb2YgdGhlIHRyZWVcbiAgICBpZiAoIWV2ZW50LmlzUG9pbnRlck92ZXJDb250YWluZXIpIHJldHVybjtcblxuICAgIC8vIGRlZXAgY2xvbmUgdGhlIGRhdGEgc291cmNlIHNvIHdlIGNhbiBtdXRhdGUgaXRcbiAgICBjb25zdCBjaGFuZ2VkRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhU291cmNlLmRhdGEpKTtcbiAgICBjb25zdCBub2RlXyA9IGNoYW5nZWREYXRhW2V2ZW50LnByZXZpb3VzSW5kZXhdXG4gICAgY29uc3Qgbm9kZUF0RGVzdDogYW55ID0gdGhpcy5kYXRhU291cmNlLmRhdGFbZXZlbnQuY3VycmVudEluZGV4XTtcbiAgICBpZiAobm9kZV8ucGFyZW50SWQgIT09IG5vZGVBdERlc3QucGFyZW50SWQpIHtcbiAgICAgIGFsZXJ0KCfku4XlhYHorrjlkIzkuIDlsYLnuqfmjpLluo8nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcmVjdXJzaXZlIGZpbmQgZnVuY3Rpb24gdG8gZmluZCBzaWJsaW5ncyBvZiBub2RlXG4gICAgZnVuY3Rpb24gZmluZE5vZGVTaWJsaW5ncyhcbiAgICAgIGFycjogQXJyYXk8YW55PixcbiAgICAgIGlkOiBzdHJpbmdcbiAgICApOiBBcnJheTxhbnk+IHwgdW5kZWZpbmVkIHtcbiAgICAgIGxldCByZXN1bHQsIHN1YlJlc3VsdDtcbiAgICAgIGFyci5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLmlkID09PSBpZCkge1xuICAgICAgICAgIHJlc3VsdCA9IGFycjtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgc3ViUmVzdWx0ID0gZmluZE5vZGVTaWJsaW5ncyhpdGVtLmNoaWxkcmVuLCBpZCk7XG4gICAgICAgICAgaWYgKHN1YlJlc3VsdCkgcmVzdWx0ID0gc3ViUmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIHdoZXJlIHRvIGluc2VydCB0aGUgbm9kZVxuXG4gICAgY29uc3QgbmV3U2libGluZ3MgPSBmaW5kTm9kZVNpYmxpbmdzKGNoYW5nZWREYXRhLCBub2RlQXREZXN0Py5pZCk7XG4gICAgaWYgKCFuZXdTaWJsaW5ncykgcmV0dXJuO1xuICAgIGNvbnN0IGluc2VydEluZGV4ID0gbmV3U2libGluZ3MuZmluZEluZGV4KChzKSA9PiBzLmlkID09PSBub2RlQXREZXN0Py5pZCk7XG5cbiAgICAvLyByZW1vdmUgdGhlIG5vZGUgZnJvbSBpdHMgb2xkIHBsYWNlXG4gICAgY29uc3Qgbm9kZSA9IGV2ZW50Lml0ZW0uZGF0YTtcbiAgICBjb25zdCBzaWJsaW5ncyA9IGZpbmROb2RlU2libGluZ3MoY2hhbmdlZERhdGEsIG5vZGUuaWQpO1xuICAgIGNvbnN0IHNpYmxpbmdJbmRleCA9IHNpYmxpbmdzPy5maW5kSW5kZXgoKG4pID0+IG4uaWQgPT09IG5vZGUuaWQpO1xuICAgIGNvbnN0IG5vZGVUb0luc2VydDogYW55ID0gc2libGluZ3M/LnNwbGljZShzaWJsaW5nSW5kZXghLCAxKVswXTtcbiAgICBpZiAobm9kZUF0RGVzdC5pZCA9PT0gbm9kZVRvSW5zZXJ0LmlkKSByZXR1cm47XG5cbiAgICAvLyBpbnNlcnQgbm9kZVxuICAgIG5ld1NpYmxpbmdzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgbm9kZVRvSW5zZXJ0KTtcblxuICAgIHRoaXMudHJlZVNlcnZpY2UubW92ZShub2RlXy5pZCwgbm9kZUF0RGVzdD8uaWQpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlYnVpbGRUcmVlRm9yRGF0YShjaGFuZ2VkRGF0YSk7XG4gICAgfSlcbiAgICAvLyByZWJ1aWxkIHRyZWUgd2l0aCBtdXRhdGVkIGRhdGFcbiAgICAvLyB0aGlzLnJlYnVpbGRUcmVlRm9yRGF0YShjaGFuZ2VkRGF0YSk7XG4gIH1cblxuICByZWJ1aWxkVHJlZUZvckRhdGEoZGF0YTogYW55KSB7XG4gICAgdGhpcy5kYXRhU291cmNlLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZXhwYW5zaW9uTW9kZWwuc2VsZWN0ZWQuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnRyZWVDb250cm9sLmRhdGFOb2Rlcy5maW5kKChuKSA9PiBuLmlkID09PSBpZCk7XG4gICAgICBub2RlLnNvcnRpbmcgPSB0cnVlXG4gICAgICB0aGlzLnRyZWVDb250cm9sLmV4cGFuZChub2RlKTtcbiAgICB9KTtcblxuICAgIC8vIHRoaXMudHJlZVNlcnZpY2UuaW5pdGlhbERhdGEoKS5zdWJzY3JpYmUocmVzID0+IHtcbiAgICAvLyAgIHRoaXMuZGF0YVNvdXJjZS5kYXRhID0gcmVzXG4gICAgLy8gICB0aGlzLmV4cGFuc2lvbk1vZGVsLnNlbGVjdGVkLmZvckVhY2goKGlkKSA9PiB7XG4gICAgLy8gICAgIGNvbnN0IG5vZGUgPSB0aGlzLnRyZWVDb250cm9sLmRhdGFOb2Rlcy5maW5kKChuKSA9PiBuLmlkID09PSBpZCk7XG4gICAgLy8gICAgIHRoaXMudHJlZUNvbnRyb2wuZXhwYW5kKG5vZGUpO1xuICAgIC8vICAgfSk7XG4gICAgLy8gfSlcblxuXG4gIH1cblxufVxuIiwiPG1hdC10cmVlXG4gIFtkYXRhU291cmNlXT1cImRhdGFTb3VyY2VcIlxuICBbdHJlZUNvbnRyb2xdPVwidHJlZUNvbnRyb2xcIlxuICBbY2RrRHJvcExpc3REYXRhXT1cImRhdGFTb3VyY2UuZGF0YVwiXG4gIGNka0Ryb3BMaXN0XG4gIChjZGtEcm9wTGlzdERyb3BwZWQpPVwiZHJvcCgkZXZlbnQpXCJcbj5cbiAgPG1hdC10cmVlLW5vZGVcbiAgICAqbWF0VHJlZU5vZGVEZWY9XCJsZXQgbm9kZVwiXG4gICAgbWF0VHJlZU5vZGVQYWRkaW5nXG4gICAgW2Nka0RyYWdEYXRhXT1cIm5vZGVcIlxuICAgIGNka0RyYWdMb2NrQXhpcz1cInlcIlxuICAgIGNka0RyYWdcbiAgPlxuICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIGRpc2FibGVkPjwvYnV0dG9uPlxuICAgIDxtYXQtY2hlY2tib3hcbiAgICAgIFtjaGVja2VkXT1cImNoZWNrbGlzdFNlbGVjdGlvblNlcnZpY2UuaXNTZWxlY3RlZChub2RlKVwiXG4gICAgICAoY2hhbmdlKT1cIm9uVG9nZ2xlKG5vZGUpXCJcbiAgICA+PC9tYXQtY2hlY2tib3g+XG4gICAgPHNwYW5cbiAgICAgIFtjbGFzc109XCJcbiAgICAgICAgc2VsZWN0ZWROb2RlID09PSBub2RlLnVybFxuICAgICAgICAgID8gJ25vcm1sLXRyZWUtbm9kZSBzZWxlY3RlZC1ub3JtbC10cmVlLW5vZGUnXG4gICAgICAgICAgOiAnbm9ybWwtdHJlZS1ub2RlJ1xuICAgICAgXCJcbiAgICAgIFtyb3V0ZXJMaW5rXT1cIm5vZGUudXJsXCJcbiAgICAgIChjbGljayk9XCJzZWxlY3RlZE5vZGUgPSBub2RlLnVybFwiXG4gICAgICA+e3sgbm9kZS5uYW1lIH19PC9zcGFuXG4gICAgPlxuICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIGNka0RyYWdMb2NrQXhpcz1cInlcIiBjZGtEcmFnSGFuZGxlPlxuICAgICAgPG1hdC1pY29uPmRyYWdfaW5kaWNhdG9yPC9tYXQtaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgPC9tYXQtdHJlZS1ub2RlPlxuXG4gIDxtYXQtdHJlZS1ub2RlXG4gICAgKm1hdFRyZWVOb2RlRGVmPVwibGV0IG5vZGU7IHdoZW46IGhhc0NoaWxkXCJcbiAgICBtYXRUcmVlTm9kZVBhZGRpbmdcbiAgICBbY2RrRHJhZ0RhdGFdPVwibm9kZVwiXG4gICAgY2RrRHJhZ0xvY2tBeGlzPVwieVwiXG4gICAgY2RrRHJhZ1xuICA+XG4gICAgPGJ1dHRvblxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBtYXQtaWNvbi1idXR0b25cbiAgICAgIG1hdFRyZWVOb2RlVG9nZ2xlXG4gICAgICBbZGlzYWJsZWRdPVwibm9kZS5pc0xvYWRpbmdcIlxuICAgICAgKGNsaWNrKT1cImV4cGFuc2lvbk1vZGVsLnRvZ2dsZShub2RlLmlkKVwiXG4gICAgPlxuICAgICAgPG1hdC1pY29uPlxuICAgICAgICB7eyB0cmVlQ29udHJvbC5pc0V4cGFuZGVkKG5vZGUpID8gXCJleHBhbmRfbW9yZVwiIDogXCJjaGV2cm9uX3JpZ2h0XCIgfX1cbiAgICAgIDwvbWF0LWljb24+XG4gICAgPC9idXR0b24+XG4gICAgPG1hdC1jaGVja2JveFxuICAgICAgW2NoZWNrZWRdPVwiY2hlY2tsaXN0U2VsZWN0aW9uU2VydmljZS5pc1NlbGVjdGVkKG5vZGUpXCJcbiAgICAgIFtpbmRldGVybWluYXRlXT1cIm5vZGUuaW5kZXRlcm1pbmF0ZVwiXG4gICAgICAoY2hhbmdlKT1cIm9uVG9nZ2xlKG5vZGUpXCJcbiAgICA+PC9tYXQtY2hlY2tib3g+XG4gICAgPHNwYW4gY2xhc3M9XCJzLWxpbmtcIj57eyBub2RlLm5hbWUgfX08L3NwYW4+XG4gICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gY2RrRHJhZ0xvY2tBeGlzPVwieVwiIGNka0RyYWdIYW5kbGU+XG4gICAgICA8bWF0LWljb24+ZHJhZ19pbmRpY2F0b3I8L21hdC1pY29uPlxuICAgIDwvYnV0dG9uPlxuICAgIDxtYXQtc3Bpbm5lciAqbmdJZj1cIm5vZGUuaXNMb2FkaW5nXCIgW2RpYW1ldGVyXT1cIjE4XCI+PC9tYXQtc3Bpbm5lcj5cbiAgICA8ZGl2XG4gICAgICBbY2xhc3MuZXhhbXBsZS10cmVlLWludmlzaWJsZV09XCIhdHJlZUNvbnRyb2wuaXNFeHBhbmRlZChub2RlKVwiXG4gICAgICByb2xlPVwiZ3JvdXBcIlxuICAgID5cbiAgICAgIDxuZy1jb250YWluZXIgbWF0VHJlZU5vZGVPdXRsZXQ+PC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG4gIDwvbWF0LXRyZWUtbm9kZT5cbjwvbWF0LXRyZWU+XG4iXX0=
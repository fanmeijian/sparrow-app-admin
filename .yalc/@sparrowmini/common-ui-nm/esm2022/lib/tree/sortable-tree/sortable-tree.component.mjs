import { FlatTreeControl } from '@angular/cdk/tree';
import { Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { SelectionModel } from '@angular/cdk/collections';
import { TREE_SERVICE, TreeDataSource } from './dynamic-data-source';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/router";
import * as i3 from "@angular/material/tree";
import * as i4 from "@angular/material/icon";
import * as i5 from "@angular/material/progress-spinner";
import * as i6 from "@angular/material/button";
import * as i7 from "@angular/cdk/drag-drop";
/***
 * 可以进行排序的树，整体管理
 */
export class SortableTreeComponent {
    constructor(treeService) {
        this.treeService = treeService;
        this.multiple = true;
        this.onTreeSelect = new EventEmitter();
        this.hasChild = (_, node) => node.expandable;
        this.treeControl = new FlatTreeControl((node) => node.level, (node) => node.expandable);
        this.dragging = false;
        this.expandDelay = 1000;
        this.validateDrop = false;
        this.expansionModel = new SelectionModel(true);
    }
    ngOnInit() {
        console.log(this.treeService);
        this.dataSource = new TreeDataSource(this.treeControl, this.treeService);
        this.treeService.initialData().subscribe(res => {
            this.dataSource.data = res;
        });
    }
    drop(event) {
        console.log('origin/destination', event.previousIndex, event.currentIndex, event);
        // ignore drops outside of the tree
        if (!event.isPointerOverContainer)
            return;
        // deep clone the data source so we can mutate it
        const changedData = JSON.parse(JSON.stringify(this.dataSource.data));
        const node_ = changedData[event.previousIndex];
        const nodeAtDest = this.dataSource.data[event.currentIndex];
        if (node_.parentId !== nodeAtDest.parentId) {
            alert('仅允许同一层级排序');
            return;
        }
        // recursive find function to find siblings of node
        function findNodeSiblings(arr, id) {
            let result, subResult;
            arr.forEach((item, i) => {
                if (item.id === id) {
                    result = arr;
                }
                else if (item.children) {
                    subResult = findNodeSiblings(item.children, id);
                    if (subResult)
                        result = subResult;
                }
            });
            return result;
        }
        // determine where to insert the node
        const newSiblings = findNodeSiblings(changedData, nodeAtDest?.id);
        if (!newSiblings)
            return;
        const insertIndex = newSiblings.findIndex((s) => s.id === nodeAtDest?.id);
        // remove the node from its old place
        const node = event.item.data;
        const siblings = findNodeSiblings(changedData, node.id);
        const siblingIndex = siblings?.findIndex((n) => n.id === node.id);
        const nodeToInsert = siblings?.splice(siblingIndex, 1)[0];
        if (nodeAtDest.id === nodeToInsert.id)
            return;
        // insert node
        newSiblings.splice(insertIndex, 0, nodeToInsert);
        this.treeService.move(node_.id, nodeAtDest?.id).subscribe(() => {
            this.rebuildTreeForData(changedData);
        });
        // rebuild tree with mutated data
        // this.rebuildTreeForData(changedData);
    }
    rebuildTreeForData(data) {
        this.dataSource.data = data;
        this.expansionModel.selected.forEach((id) => {
            const node = this.treeControl.dataNodes.find((n) => n.id === id);
            node.sorting = true;
            this.treeControl.expand(node);
        });
        // this.treeService.initialData().subscribe(res => {
        //   this.dataSource.data = res
        //   this.expansionModel.selected.forEach((id) => {
        //     const node = this.treeControl.dataNodes.find((n) => n.id === id);
        //     this.treeControl.expand(node);
        //   });
        // })
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SortableTreeComponent, deps: [{ token: TREE_SERVICE }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SortableTreeComponent, selector: "spr-sortable-tree", inputs: { multiple: "multiple" }, outputs: { onTreeSelect: "onTreeSelect" }, ngImport: i0, template: "<mat-tree\n  [dataSource]=\"dataSource\"\n  [treeControl]=\"treeControl\"\n  [cdkDropListData]=\"dataSource.data\"\n  cdkDropList\n  (cdkDropListDropped)=\"drop($event)\"\n>\n  <mat-tree-node\n    *matTreeNodeDef=\"let node\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button mat-icon-button disabled></button>\n    <span\n      [class]=\"\n        selectedNode === node.url\n          ? 'norml-tree-node selected-norml-tree-node'\n          : 'norml-tree-node'\n      \"\n      [routerLink]=\"node.url\"\n      (click)=\"selectedNode = node.url\"\n      >{{ node.name }}</span\n    >\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n  </mat-tree-node>\n\n  <mat-tree-node\n    *matTreeNodeDef=\"let node; when: hasChild\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button\n      type=\"button\"\n      mat-icon-button\n      matTreeNodeToggle\n      [disabled]=\"node.isLoading\"\n      (click)=\"expansionModel.toggle(node.id)\"\n    >\n      <mat-icon>\n        {{ treeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\n      </mat-icon>\n    </button>\n    <span class=\"s-link\">{{ node.name }}</span>\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n    <mat-spinner *ngIf=\"node.isLoading\" [diameter]=\"18\"></mat-spinner>\n    <div\n      [class.example-tree-invisible]=\"!treeControl.isExpanded(node)\"\n      role=\"group\"\n    >\n      <ng-container matTreeNodeOutlet></ng-container>\n    </div>\n  </mat-tree-node>\n</mat-tree>\n", styles: [""], dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: i3.MatTreeNodeDef, selector: "[matTreeNodeDef]", inputs: ["matTreeNodeDefWhen", "matTreeNode"] }, { kind: "directive", type: i3.MatTreeNodePadding, selector: "[matTreeNodePadding]", inputs: ["matTreeNodePadding", "matTreeNodePaddingIndent"] }, { kind: "directive", type: i3.MatTreeNodeToggle, selector: "[matTreeNodeToggle]", inputs: ["matTreeNodeToggleRecursive"] }, { kind: "component", type: i3.MatTree, selector: "mat-tree", exportAs: ["matTree"] }, { kind: "directive", type: i3.MatTreeNode, selector: "mat-tree-node", inputs: ["role", "disabled", "tabIndex"], exportAs: ["matTreeNode"] }, { kind: "directive", type: i3.MatTreeNodeOutlet, selector: "[matTreeNodeOutlet]" }, { kind: "component", type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i5.MatProgressSpinner, selector: "mat-progress-spinner, mat-spinner", inputs: ["color", "mode", "value", "diameter", "strokeWidth"], exportAs: ["matProgressSpinner"] }, { kind: "component", type: i6.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i7.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "cdkDropListData", "cdkDropListOrientation", "id", "cdkDropListLockAxis", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListAutoScrollDisabled", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { kind: "directive", type: i7.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragData", "cdkDragLockAxis", "cdkDragRootElement", "cdkDragBoundary", "cdkDragStartDelay", "cdkDragFreeDragPosition", "cdkDragDisabled", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragPreviewContainer"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { kind: "directive", type: i7.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SortableTreeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'spr-sortable-tree', template: "<mat-tree\n  [dataSource]=\"dataSource\"\n  [treeControl]=\"treeControl\"\n  [cdkDropListData]=\"dataSource.data\"\n  cdkDropList\n  (cdkDropListDropped)=\"drop($event)\"\n>\n  <mat-tree-node\n    *matTreeNodeDef=\"let node\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button mat-icon-button disabled></button>\n    <span\n      [class]=\"\n        selectedNode === node.url\n          ? 'norml-tree-node selected-norml-tree-node'\n          : 'norml-tree-node'\n      \"\n      [routerLink]=\"node.url\"\n      (click)=\"selectedNode = node.url\"\n      >{{ node.name }}</span\n    >\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n  </mat-tree-node>\n\n  <mat-tree-node\n    *matTreeNodeDef=\"let node; when: hasChild\"\n    matTreeNodePadding\n    [cdkDragData]=\"node\"\n    cdkDragLockAxis=\"y\"\n    cdkDrag\n  >\n    <button\n      type=\"button\"\n      mat-icon-button\n      matTreeNodeToggle\n      [disabled]=\"node.isLoading\"\n      (click)=\"expansionModel.toggle(node.id)\"\n    >\n      <mat-icon>\n        {{ treeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\n      </mat-icon>\n    </button>\n    <span class=\"s-link\">{{ node.name }}</span>\n    <button mat-icon-button cdkDragLockAxis=\"y\" cdkDragHandle>\n      <mat-icon>drag_indicator</mat-icon>\n    </button>\n    <mat-spinner *ngIf=\"node.isLoading\" [diameter]=\"18\"></mat-spinner>\n    <div\n      [class.example-tree-invisible]=\"!treeControl.isExpanded(node)\"\n      role=\"group\"\n    >\n      <ng-container matTreeNodeOutlet></ng-container>\n    </div>\n  </mat-tree-node>\n</mat-tree>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [TREE_SERVICE]
                }] }]; }, propDecorators: { multiple: [{
                type: Input
            }], onTreeSelect: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydGFibGUtdHJlZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb21tb24tdWktbm0vc3JjL2xpYi90cmVlL3NvcnRhYmxlLXRyZWUvc29ydGFibGUtdHJlZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb21tb24tdWktbm0vc3JjL2xpYi90cmVlL3NvcnRhYmxlLXRyZWUvc29ydGFibGUtdHJlZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFcEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDL0UsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRTFELE9BQU8sRUFBbUIsWUFBWSxFQUFFLGNBQWMsRUFBZSxNQUFNLHVCQUF1QixDQUFDOzs7Ozs7Ozs7QUFFbkc7O0dBRUc7QUFPSCxNQUFNLE9BQU8scUJBQXFCO0lBT2hDLFlBQytCLFdBQXdCO1FBQXhCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBUDlDLGFBQVEsR0FBWSxJQUFJLENBQUE7UUFDdkIsaUJBQVksR0FBb0MsSUFBSSxZQUFZLEVBQXFCLENBQUE7UUFnQi9GLGFBQVEsR0FBRyxDQUFDLENBQVMsRUFBRSxJQUFxQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBR2pFLGdCQUFXLEdBQUcsSUFBSSxlQUFlLENBQy9CLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUNwQixDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FDMUIsQ0FBQztRQUlGLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFFakIs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NkRBOzs0RkQ3Q2EscUJBQXFCO2tCQUxqQyxTQUFTOytCQUNFLG1CQUFtQjs7MEJBWTFCLE1BQU07MkJBQUMsWUFBWTs0Q0FQYixRQUFRO3NCQUFoQixLQUFLO2dCQUNJLFlBQVk7c0JBQXJCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGbGF0VHJlZUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9jZGsvdHJlZSc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VsZWN0aW9uTW9kZWwgfSBmcm9tICdAYW5ndWxhci9jZGsvY29sbGVjdGlvbnMnO1xuaW1wb3J0IHsgQ2RrRHJhZ0Ryb3AgfSBmcm9tICdAYW5ndWxhci9jZGsvZHJhZy1kcm9wJztcbmltcG9ydCB7IER5bmFtaWNGbGF0Tm9kZSwgVFJFRV9TRVJWSUNFLCBUcmVlRGF0YVNvdXJjZSwgVHJlZVNlcnZpY2UgfSBmcm9tICcuL2R5bmFtaWMtZGF0YS1zb3VyY2UnO1xuXG4vKioqXG4gKiDlj6/ku6Xov5vooYzmjpLluo/nmoTmoJHvvIzmlbTkvZPnrqHnkIZcbiAqL1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdzcHItc29ydGFibGUtdHJlZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9zb3J0YWJsZS10cmVlLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vc29ydGFibGUtdHJlZS5jb21wb25lbnQuY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgU29ydGFibGVUcmVlQ29tcG9uZW50IHtcbiAgQElucHV0KCkgbXVsdGlwbGU6IGJvb2xlYW4gPSB0cnVlXG4gIEBPdXRwdXQoKSBvblRyZWVTZWxlY3Q6IEV2ZW50RW1pdHRlcjxEeW5hbWljRmxhdE5vZGVbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPER5bmFtaWNGbGF0Tm9kZVtdPigpXG5cbiAgZGF0YVNvdXJjZSE6IFRyZWVEYXRhU291cmNlO1xuICBzZWxlY3RlZE5vZGU6IGFueTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KFRSRUVfU0VSVklDRSkgcHVibGljIHRyZWVTZXJ2aWNlOiBUcmVlU2VydmljZVxuICApIHsgfVxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnRyZWVTZXJ2aWNlKVxuICAgIHRoaXMuZGF0YVNvdXJjZSA9IG5ldyBUcmVlRGF0YVNvdXJjZSh0aGlzLnRyZWVDb250cm9sLCB0aGlzLnRyZWVTZXJ2aWNlKTtcbiAgICB0aGlzLnRyZWVTZXJ2aWNlLmluaXRpYWxEYXRhKCkuc3Vic2NyaWJlKHJlcyA9PiB7XG4gICAgICB0aGlzLmRhdGFTb3VyY2UuZGF0YSA9IHJlc1xuICAgIH0pXG4gIH1cblxuICBoYXNDaGlsZCA9IChfOiBudW1iZXIsIG5vZGU6IER5bmFtaWNGbGF0Tm9kZSkgPT4gbm9kZS5leHBhbmRhYmxlO1xuXG5cbiAgdHJlZUNvbnRyb2wgPSBuZXcgRmxhdFRyZWVDb250cm9sPGFueT4oXG4gICAgKG5vZGUpID0+IG5vZGUubGV2ZWwsXG4gICAgKG5vZGUpID0+IG5vZGUuZXhwYW5kYWJsZVxuICApO1xuXG5cblxuICBkcmFnZ2luZyA9IGZhbHNlO1xuICBleHBhbmRUaW1lb3V0OiBhbnk7XG4gIGV4cGFuZERlbGF5ID0gMTAwMDtcbiAgdmFsaWRhdGVEcm9wID0gZmFsc2U7XG4gIGV4cGFuc2lvbk1vZGVsID0gbmV3IFNlbGVjdGlvbk1vZGVsPHN0cmluZz4odHJ1ZSk7XG4gIGRyb3AoZXZlbnQ6IGFueSkge1xuICAgIGNvbnNvbGUubG9nKCdvcmlnaW4vZGVzdGluYXRpb24nLCBldmVudC5wcmV2aW91c0luZGV4LCBldmVudC5jdXJyZW50SW5kZXgsIGV2ZW50KTtcblxuICAgIC8vIGlnbm9yZSBkcm9wcyBvdXRzaWRlIG9mIHRoZSB0cmVlXG4gICAgaWYgKCFldmVudC5pc1BvaW50ZXJPdmVyQ29udGFpbmVyKSByZXR1cm47XG5cbiAgICAvLyBkZWVwIGNsb25lIHRoZSBkYXRhIHNvdXJjZSBzbyB3ZSBjYW4gbXV0YXRlIGl0XG4gICAgY29uc3QgY2hhbmdlZERhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YVNvdXJjZS5kYXRhKSk7XG4gICAgY29uc3Qgbm9kZV8gPSBjaGFuZ2VkRGF0YVtldmVudC5wcmV2aW91c0luZGV4XVxuICAgIGNvbnN0IG5vZGVBdERlc3Q6IGFueSA9IHRoaXMuZGF0YVNvdXJjZS5kYXRhW2V2ZW50LmN1cnJlbnRJbmRleF07XG4gICAgaWYgKG5vZGVfLnBhcmVudElkICE9PSBub2RlQXREZXN0LnBhcmVudElkKSB7XG4gICAgICBhbGVydCgn5LuF5YWB6K645ZCM5LiA5bGC57qn5o6S5bqPJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJlY3Vyc2l2ZSBmaW5kIGZ1bmN0aW9uIHRvIGZpbmQgc2libGluZ3Mgb2Ygbm9kZVxuICAgIGZ1bmN0aW9uIGZpbmROb2RlU2libGluZ3MoXG4gICAgICBhcnI6IEFycmF5PGFueT4sXG4gICAgICBpZDogc3RyaW5nXG4gICAgKTogQXJyYXk8YW55PiB8IHVuZGVmaW5lZCB7XG4gICAgICBsZXQgcmVzdWx0LCBzdWJSZXN1bHQ7XG4gICAgICBhcnIuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBpZiAoaXRlbS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICByZXN1bHQgPSBhcnI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgIHN1YlJlc3VsdCA9IGZpbmROb2RlU2libGluZ3MoaXRlbS5jaGlsZHJlbiwgaWQpO1xuICAgICAgICAgIGlmIChzdWJSZXN1bHQpIHJlc3VsdCA9IHN1YlJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSB3aGVyZSB0byBpbnNlcnQgdGhlIG5vZGVcblxuICAgIGNvbnN0IG5ld1NpYmxpbmdzID0gZmluZE5vZGVTaWJsaW5ncyhjaGFuZ2VkRGF0YSwgbm9kZUF0RGVzdD8uaWQpO1xuICAgIGlmICghbmV3U2libGluZ3MpIHJldHVybjtcbiAgICBjb25zdCBpbnNlcnRJbmRleCA9IG5ld1NpYmxpbmdzLmZpbmRJbmRleCgocykgPT4gcy5pZCA9PT0gbm9kZUF0RGVzdD8uaWQpO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBub2RlIGZyb20gaXRzIG9sZCBwbGFjZVxuICAgIGNvbnN0IG5vZGUgPSBldmVudC5pdGVtLmRhdGE7XG4gICAgY29uc3Qgc2libGluZ3MgPSBmaW5kTm9kZVNpYmxpbmdzKGNoYW5nZWREYXRhLCBub2RlLmlkKTtcbiAgICBjb25zdCBzaWJsaW5nSW5kZXggPSBzaWJsaW5ncz8uZmluZEluZGV4KChuKSA9PiBuLmlkID09PSBub2RlLmlkKTtcbiAgICBjb25zdCBub2RlVG9JbnNlcnQ6IGFueSA9IHNpYmxpbmdzPy5zcGxpY2Uoc2libGluZ0luZGV4ISwgMSlbMF07XG4gICAgaWYgKG5vZGVBdERlc3QuaWQgPT09IG5vZGVUb0luc2VydC5pZCkgcmV0dXJuO1xuXG4gICAgLy8gaW5zZXJ0IG5vZGVcbiAgICBuZXdTaWJsaW5ncy5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsIG5vZGVUb0luc2VydCk7XG5cbiAgICB0aGlzLnRyZWVTZXJ2aWNlLm1vdmUobm9kZV8uaWQsIG5vZGVBdERlc3Q/LmlkKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5yZWJ1aWxkVHJlZUZvckRhdGEoY2hhbmdlZERhdGEpO1xuICAgIH0pXG4gICAgLy8gcmVidWlsZCB0cmVlIHdpdGggbXV0YXRlZCBkYXRhXG4gICAgLy8gdGhpcy5yZWJ1aWxkVHJlZUZvckRhdGEoY2hhbmdlZERhdGEpO1xuICB9XG5cbiAgcmVidWlsZFRyZWVGb3JEYXRhKGRhdGE6IGFueSkge1xuICAgIHRoaXMuZGF0YVNvdXJjZS5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmV4cGFuc2lvbk1vZGVsLnNlbGVjdGVkLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy50cmVlQ29udHJvbC5kYXRhTm9kZXMuZmluZCgobikgPT4gbi5pZCA9PT0gaWQpO1xuICAgICAgbm9kZS5zb3J0aW5nPXRydWVcbiAgICAgIHRoaXMudHJlZUNvbnRyb2wuZXhwYW5kKG5vZGUpO1xuICAgIH0pO1xuXG4gICAgLy8gdGhpcy50cmVlU2VydmljZS5pbml0aWFsRGF0YSgpLnN1YnNjcmliZShyZXMgPT4ge1xuICAgIC8vICAgdGhpcy5kYXRhU291cmNlLmRhdGEgPSByZXNcbiAgICAvLyAgIHRoaXMuZXhwYW5zaW9uTW9kZWwuc2VsZWN0ZWQuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAvLyAgICAgY29uc3Qgbm9kZSA9IHRoaXMudHJlZUNvbnRyb2wuZGF0YU5vZGVzLmZpbmQoKG4pID0+IG4uaWQgPT09IGlkKTtcbiAgICAvLyAgICAgdGhpcy50cmVlQ29udHJvbC5leHBhbmQobm9kZSk7XG4gICAgLy8gICB9KTtcbiAgICAvLyB9KVxuXG5cbiAgfVxuXG59XG4iLCI8bWF0LXRyZWVcbiAgW2RhdGFTb3VyY2VdPVwiZGF0YVNvdXJjZVwiXG4gIFt0cmVlQ29udHJvbF09XCJ0cmVlQ29udHJvbFwiXG4gIFtjZGtEcm9wTGlzdERhdGFdPVwiZGF0YVNvdXJjZS5kYXRhXCJcbiAgY2RrRHJvcExpc3RcbiAgKGNka0Ryb3BMaXN0RHJvcHBlZCk9XCJkcm9wKCRldmVudClcIlxuPlxuICA8bWF0LXRyZWUtbm9kZVxuICAgICptYXRUcmVlTm9kZURlZj1cImxldCBub2RlXCJcbiAgICBtYXRUcmVlTm9kZVBhZGRpbmdcbiAgICBbY2RrRHJhZ0RhdGFdPVwibm9kZVwiXG4gICAgY2RrRHJhZ0xvY2tBeGlzPVwieVwiXG4gICAgY2RrRHJhZ1xuICA+XG4gICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gZGlzYWJsZWQ+PC9idXR0b24+XG4gICAgPHNwYW5cbiAgICAgIFtjbGFzc109XCJcbiAgICAgICAgc2VsZWN0ZWROb2RlID09PSBub2RlLnVybFxuICAgICAgICAgID8gJ25vcm1sLXRyZWUtbm9kZSBzZWxlY3RlZC1ub3JtbC10cmVlLW5vZGUnXG4gICAgICAgICAgOiAnbm9ybWwtdHJlZS1ub2RlJ1xuICAgICAgXCJcbiAgICAgIFtyb3V0ZXJMaW5rXT1cIm5vZGUudXJsXCJcbiAgICAgIChjbGljayk9XCJzZWxlY3RlZE5vZGUgPSBub2RlLnVybFwiXG4gICAgICA+e3sgbm9kZS5uYW1lIH19PC9zcGFuXG4gICAgPlxuICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIGNka0RyYWdMb2NrQXhpcz1cInlcIiBjZGtEcmFnSGFuZGxlPlxuICAgICAgPG1hdC1pY29uPmRyYWdfaW5kaWNhdG9yPC9tYXQtaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgPC9tYXQtdHJlZS1ub2RlPlxuXG4gIDxtYXQtdHJlZS1ub2RlXG4gICAgKm1hdFRyZWVOb2RlRGVmPVwibGV0IG5vZGU7IHdoZW46IGhhc0NoaWxkXCJcbiAgICBtYXRUcmVlTm9kZVBhZGRpbmdcbiAgICBbY2RrRHJhZ0RhdGFdPVwibm9kZVwiXG4gICAgY2RrRHJhZ0xvY2tBeGlzPVwieVwiXG4gICAgY2RrRHJhZ1xuICA+XG4gICAgPGJ1dHRvblxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBtYXQtaWNvbi1idXR0b25cbiAgICAgIG1hdFRyZWVOb2RlVG9nZ2xlXG4gICAgICBbZGlzYWJsZWRdPVwibm9kZS5pc0xvYWRpbmdcIlxuICAgICAgKGNsaWNrKT1cImV4cGFuc2lvbk1vZGVsLnRvZ2dsZShub2RlLmlkKVwiXG4gICAgPlxuICAgICAgPG1hdC1pY29uPlxuICAgICAgICB7eyB0cmVlQ29udHJvbC5pc0V4cGFuZGVkKG5vZGUpID8gXCJleHBhbmRfbW9yZVwiIDogXCJjaGV2cm9uX3JpZ2h0XCIgfX1cbiAgICAgIDwvbWF0LWljb24+XG4gICAgPC9idXR0b24+XG4gICAgPHNwYW4gY2xhc3M9XCJzLWxpbmtcIj57eyBub2RlLm5hbWUgfX08L3NwYW4+XG4gICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gY2RrRHJhZ0xvY2tBeGlzPVwieVwiIGNka0RyYWdIYW5kbGU+XG4gICAgICA8bWF0LWljb24+ZHJhZ19pbmRpY2F0b3I8L21hdC1pY29uPlxuICAgIDwvYnV0dG9uPlxuICAgIDxtYXQtc3Bpbm5lciAqbmdJZj1cIm5vZGUuaXNMb2FkaW5nXCIgW2RpYW1ldGVyXT1cIjE4XCI+PC9tYXQtc3Bpbm5lcj5cbiAgICA8ZGl2XG4gICAgICBbY2xhc3MuZXhhbXBsZS10cmVlLWludmlzaWJsZV09XCIhdHJlZUNvbnRyb2wuaXNFeHBhbmRlZChub2RlKVwiXG4gICAgICByb2xlPVwiZ3JvdXBcIlxuICAgID5cbiAgICAgIDxuZy1jb250YWluZXIgbWF0VHJlZU5vZGVPdXRsZXQ+PC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG4gIDwvbWF0LXRyZWUtbm9kZT5cbjwvbWF0LXRyZWU+XG4iXX0=